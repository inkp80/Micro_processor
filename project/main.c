
#include <avr/pgmspace.h>
#include <avr/io.h>
#include <avr/interrupt.h>
#include "_main.h"
#include "_glcd.h"
#include "_adc.h"

unsigned int Data_ADC3 = 0;
unsigned int Data_ADC4 = 0;

unsigned int box_state = 0;
unsigned int power_cnt = 0;
unsigned char life = 0;       // power_cnt를 일정량 채워 얻는 life양
unsigned char game_state = 0; // game의 상태(0: 메뉴선택화면, 1: Credit 출력, 2: 점프게이지 화면, 3: 점프 후 새 피하기, 5: 게임오버/게임클리어
unsigned int t0_cnt = 0;
unsigned int t0_count = 0;

unsigned char flag[3];         // 새가 화면에 출력되어있는 상태인지 체크하는 flag
unsigned char stage_number = 0; // stage 번호
unsigned int play_time = 0;      // case 3의 새 피하기 시작후 지난 시간
unsigned int round_time = 28 * 20; // 하나의 stage당 진행시간
unsigned char end_flag = 0;  // game over인지 game clear인지 체크하는 flag
unsigned char game_flag = 0; // case 3의 새 피하기를 시작했나를 체크하는 flag
unsigned char crash_flag[3]; // 새가 점프보이와 충돌 중인가를 체크하는 flag
unsigned int max_score = 0;  // 최고 점수
unsigned int cur_score = 0;  // 현재 점수

void Init_Timer0();
void Port_init();         // 포트 초기화
void init_devices();
void ending_display();      // end_flag에 따라 game over또는 game clear와 점수를 출력해주는 함수
void next_stage_display();  // 다음 stage로 넘어감을 알리는 함수
void print_bitmap(unsigned char *, unsigned char, unsigned char, unsigned char, unsigned char); // 그림을 해당 위치에 해당 크기만큼 출력하는 함수
void joystick_move(unsigned char*, unsigned char*); // 조이스틱으로 점프보이로 움직임

unsigned int cnt;      // start_time과 비교하여 play_time보다 커지면 새를 화면에 내보냄
unsigned int t0_count;

unsigned char img[1024] = { //로고 이미지 (SUPER JUMP BOY)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xEE, 0x3F, 0xFD, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x02, 0x04, 0x00, 0x01, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00,

	0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xF2, 0x0C, 0xF3, 0x3F, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x4F, 0xF2, 0x4C, 0xF3, 0x3F, 0x9E, 0x40, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x62, 0x4C, 0xE3, 0x01, 0x9C, 0x40, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x22, 0x48, 0x07, 0x3F, 0x80, 0xC0, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x66, 0x48, 0xFF, 0x3F, 0x8E, 0x40, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x01, 0xDE, 0x66, 0x88, 0xFF, 0x3F, 0xCF, 0x20, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x40, 0x08, 0xFF, 0x00, 0x4F, 0x90, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0xE0, 0x18, 0xFF, 0x00, 0x47, 0x90, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF3, 0xC1, 0xE0, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x20, 0x08, 0xF9, 0x8F, 0x8C, 0x03, 0x80, 0x78, 0x06, 0x21, 0x20, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x18, 0xF1, 0x0F, 0x0C, 0x01, 0x80, 0x10, 0x03, 0x03, 0x10, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x7F, 0x19, 0xF1, 0x07, 0x08, 0xF0, 0x8F, 0x10, 0xF1, 0x13, 0x80, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x7F, 0x11, 0xF1, 0x06, 0x08, 0xF8, 0x8F, 0x98, 0xF8, 0x8B, 0x08, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x7E, 0x31, 0xE3, 0x06, 0x08, 0xF8, 0x8F, 0x88, 0xF8, 0xC3, 0x08, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x3E, 0x23, 0xE2, 0x04, 0x08, 0xF8, 0x8F, 0x18, 0xFC, 0xF0, 0x08, 0x00, 0x00,

	0x00, 0x00, 0x00, 0x3C, 0x63, 0xE2, 0x21, 0x88, 0x00, 0xC0, 0x78, 0x7C, 0x7C, 0x10, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x3C, 0x47, 0xC2, 0x31, 0x88, 0x00, 0xC0, 0x1C, 0x7C, 0x3E, 0x10, 0x00, 0x00,
	0x00, 0x00, 0x03, 0xF8, 0xC7, 0x86, 0x33, 0x08, 0x03, 0xC7, 0x8C, 0x7E, 0x3F, 0x10, 0x00, 0x00,
	0x00, 0x00, 0x08, 0xF8, 0x87, 0xC4, 0x33, 0x08, 0xFF, 0xC7, 0xC4, 0x7E, 0x3F, 0x10, 0x00, 0x00,
	0x00, 0x00, 0x11, 0xD1, 0x8F, 0x84, 0x7F, 0x18, 0xFF, 0xC7, 0xC4, 0x1E, 0x1F, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x10, 0xE1, 0x07, 0x8C, 0x7F, 0x18, 0xFF, 0xC7, 0x86, 0x3E, 0x1F, 0x88, 0x00, 0x00,
	0x00, 0x00, 0x20, 0x03, 0x00, 0x08, 0x7F, 0x18, 0xFF, 0xC0, 0x02, 0x00, 0x0F, 0x80, 0x00, 0x00,
	0x00, 0x00, 0x20, 0x07, 0x00, 0x18, 0x7F, 0x18, 0xFF, 0x40, 0x07, 0x00, 0x0F, 0xC4, 0x00, 0x00,
	0x00, 0x00, 0x20, 0x0F, 0x00, 0x38, 0xEF, 0x18, 0xFF, 0x40, 0x07, 0x80, 0x1F, 0xC2, 0x00, 0x00,
	0x00, 0x00, 0x1F, 0xFF, 0xFF, 0xFF, 0xEF, 0xFF, 0xFE, 0x7F, 0xFF, 0xFF, 0xF7, 0xFE, 0x00, 0x00,
	0x00, 0x00, 0x1F, 0xFF, 0xFF, 0xFF, 0xEF, 0xFF, 0xFC, 0x7F, 0xFF, 0xFF, 0xE7, 0xFE, 0x00, 0x00,
	0x00, 0x00, 0x1F, 0xFF, 0xFF, 0xFF, 0xE1, 0xFF, 0x80, 0x7F, 0xFF, 0xFF, 0xE3, 0xFC, 0x00, 0x00,
	0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xE1, 0xFF, 0x80, 0x7F, 0xFF, 0xFF, 0xE3, 0xFC, 0x00, 0x00,
	0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xC1, 0xFF, 0x80, 0x7F, 0xFF, 0xFF, 0xC3, 0xFC, 0x00, 0x00,
	0x00, 0x00, 0x07, 0xFF, 0x3F, 0xFF, 0xC1, 0xFF, 0x80, 0x7F, 0xFB, 0xFF, 0xC1, 0xF8, 0x00, 0x00,
	0x00, 0x00, 0x07, 0xFE, 0x3F, 0xFF, 0xC1, 0xFF, 0x80, 0x7F, 0xF3, 0xFF, 0xC1, 0xF8, 0x00, 0x00,

	0x00, 0x00, 0x01, 0xF8, 0x0F, 0xC7, 0xC0, 0xFF, 0x80, 0x7F, 0xC0, 0x7F, 0x00, 0xF0, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00

};

unsigned char esc[1024] = { //GAME START 직후 삽입 이미지
	0x00, 0x7F, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x7F, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x7F, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x7F, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x7F, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x3F, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x1F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00,
	0xFF, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xF8, 0x00, 0x00, 0x7F, 0x80, 0x00, 0x00,
	0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0x80, 0x01, 0xFF, 0xE0, 0x00, 0x00,
	0xFF, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xE0, 0x01, 0xFF, 0xF0, 0x00, 0x00,
	0xFF, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xF8, 0x03, 0xFF, 0xF0, 0x00, 0x00,
	0xFF, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0xF0, 0x00, 0x00,
	0x7F, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xF0, 0x7F, 0xFF, 0xFF, 0xFF, 0xE0, 0x00, 0x00,
	0x7F, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x80, 0x1F, 0xFF, 0xFF, 0xFF, 0xE0, 0x00, 0x00,
	0x7F, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x07, 0xFC, 0x00, 0x07, 0xFF, 0xFF, 0xFF, 0xE0, 0x00, 0x00,
	0x7F, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x1F, 0xE0, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xE0, 0x00, 0x00,

	0x7F, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x7F, 0x80, 0x00, 0x07, 0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00,
	0xFF, 0xFF, 0x80, 0x18, 0x00, 0x1F, 0xFE, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00,
	0xFF, 0xFF, 0x80, 0x3E, 0x00, 0x07, 0xFE, 0x00, 0x00, 0x3F, 0xFF, 0xFF, 0xDC, 0x00, 0x00, 0x00,
	0xFF, 0xFF, 0x80, 0x3F, 0x00, 0x3F, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x00,
	0xFF, 0xFF, 0x80, 0xFF, 0x00, 0x03, 0xE7, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x20, 0x00,
	0xFF, 0xFF, 0x87, 0xFE, 0x00, 0x0E, 0xC3, 0x00, 0x07, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x24, 0x00,
	0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x19, 0x80, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xE0, 0x0C, 0xF8, 0x00,
	0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x03, 0x00, 0x00, 0x3F, 0xFF, 0xFF, 0xEF, 0xF0, 0x07, 0xF4, 0x00,
	0xFF, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xC7, 0xFE, 0x07, 0xF0, 0x00,
	0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x03, 0xFF, 0xCF, 0xF8, 0x00,
	0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFC, 0x03, 0xFF, 0xFF, 0xC0, 0x00,
	0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xFF, 0xFF, 0xF0, 0x00, 0xFF, 0xFE, 0x00, 0x00,
	0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFF, 0xFF, 0xE0, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00,

	0xFF, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xE0, 0x00, 0x00, 0x00, 0x00,
	0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00,
	0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE0, 0x00, 0x00, 0x00,
	0xFC, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x00, 0x00, 0x00,
	0xF8, 0x7F, 0xFF, 0xE0, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x00, 0x00, 0x00,
	0xF0, 0x03, 0xFF, 0xF0, 0x00, 0x00, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x00, 0x00, 0x00,
	0xE0, 0x00, 0xFF, 0xF8, 0x00, 0x00, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x00, 0x00, 0x00,
	0xC0, 0x00, 0x3F, 0xF8, 0x00, 0x00, 0x7F, 0xFF, 0xF0, 0x1F, 0xFF, 0x8F, 0xF0, 0x00, 0x00, 0x00,
	0x80, 0x00, 0x0F, 0xF8, 0x00, 0x00, 0xFF, 0xFF, 0xC0, 0x00, 0xF0, 0x07, 0xF0, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x07, 0xF8, 0x00, 0x01, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x0F, 0xF0, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x07, 0xF8, 0x03, 0xF3, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x0F, 0xF0, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x07, 0xF8, 0x7F, 0xFF, 0xFF, 0xE0, 0x00, 0x00, 0x00, 0x0F, 0xF0, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x0F, 0xE0, 0x00, 0x00, 0x00,
	0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xE0, 0x00, 0x00, 0x00,
	0x00, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xE0, 0x00, 0x00, 0x00,

	0x00, 0x0F, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xE0, 0x00, 0x00, 0x00,
	0x00, 0x0F, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xE0, 0x00, 0x00, 0x00,
	0x00, 0x0F, 0xFC, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xE0, 0x00, 0x00, 0x00,
	0x00, 0x0F, 0xE0, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xE0, 0x00, 0x00, 0x00,
	0x00, 0x0F, 0xC0, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xC0, 0x00, 0x00, 0x00,
	0x00, 0x0F, 0xC0, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xC0, 0x00, 0x00, 0x00,
	0x00, 0x0F, 0xC0, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xC0, 0x00, 0x00, 0x00,
	0x00, 0x07, 0x80, 0x1F, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xE0, 0x00, 0x00, 0x00,
	0x00, 0x03, 0x80, 0x1F, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xF0, 0x00, 0x00, 0x00,
	0x00, 0x01, 0x00, 0x1F, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xFC, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x0F, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xFF, 0xFE, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x0F, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xFF, 0xFF, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x1F, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFE, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x1F, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xF8, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x3F, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFE, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x3F, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00

};

unsigned char lin[8] = { //시작화면 삽입 이미지 사람1
	0x38,
	0x38,
	0x1b,
	0xef,
	0xd8,
	0x28,
	0x24,
	0x6c
};

unsigned char jumper[32] = { //16*16 super jump boy로 변신한 사람
	0x01, 0xf0,
	0x01, 0xf0,
	0x01, 0xf0,
	0x7f, 0xce,
	0x7f, 0xfe,
	0x73, 0xfe,
	0x73, 0xe0,
	0x03, 0xe0,
	0x03, 0xe0,
	0x03, 0xfc,
	0x03, 0xfc,
	0x07, 0x1c,
	0x7f, 0x1c,
	0x7f, 0x1c,
	0x60, 0x1f,
	0x60, 0x1f,
};


unsigned char bird[8] = { //장애물 및 메뉴 화면 출력되는 오브젝트
	0x02,
	0x06,
	0x6e,
	0xee,
	0x7c,
	0x3c,
	0x1f,
	0x00
};

unsigned char base1[] = { //게이지 모으는 과정에서 변신 전 사람
	0x30,
	0x30,
	0x7e,
	0xba,
	0x38,
	0x28,
	0x28,
	0x68
};

typedef struct{        // 새의 x, y좌표를 가지는 구조체
	unsigned char x;
	unsigned char y;
}Bird;

// 새의 좌표를 설정해주는 함수
void set_Bird(unsigned char *y, unsigned char *x, unsigned char y_val){
	*x = 120;
	*y = y_val;
}

// 번호가 bird_num인 새를 해당 x, y좌표에 출력해주는 함수
void fly(unsigned start_time, unsigned char *y, unsigned char *x, unsigned char bird_num){
	// cnt가 start_time보다 커지면 번호가 bird_num인 새를 화면에 출력. 한 번 출력되면 stage가 끝날 때까지 계속해서 화면에 나타난다.
	if (flag[bird_num] || cnt > start_time){
		flag[bird_num] = 1;
		*x -= 6 + stage_number; // stage번호가 커짐에 따라 새의 속도가 빨라짐
		print_bitmap(bird, *x - 4, *y - 4, 8, 8); // 해당위치에 새의 그림을 출력
		if (*x <= 9){
			set_Bird(y, x, (*y*power_cnt) % 53 + 4); // 새가 화면에서 사라졌을 때, 다른 좌표에 다시 출력
		}
	}
}


void Init_Timer0(void){ //타이머 인터럽트를 위한 관련 레지스터 초기화
	TCCR0 = 0x77;
	TCNT0 = 0;
	SREG = 0x80;
	TIMSK = 0x01;
}

void init_INT(void){ //버튼 PD0, PD1의 눌렸을 때 인터럽트를 걸기 위한 초기화 과정
	EICRA = 0x08;
	EIMSK = 0x03;
	SREG |= 0x80;
}

ISR(TIMER0_OVF_vect){ //타이머 TIMER0의 인터럽트 발생시 핸들러
	cnt++; //인터럽트 발생 횟수의 카운터
	t0_cnt++; //이하 동일
	if (t0_cnt == 28){ // 28 정도면 1초
		t0_count++; //1초당 t0_count가 1 증가한다
		t0_cnt = 0;
	}
	if (game_flag == 1) cur_score++;  // 점프보이가 장애물 회피 단계 시작되면 현재 점수가 1씩 증가한다.
	if (cnt > 150) cnt = 0;
	play_time++; // play_time이 1씩 증가. play_time이 round_time보다 커질 때, stage 종료
}

//game_state = 게임 단계를 서술하기 위한 flag이다.

ISR(INT0_vect){//PD0 버튼을 눌렀을 때의 인터럽트 핸들을 위한 함수
	if (game_state == 0){ //커서가 game start를 가리키고 있을 때의 상태 state = 0
		game_state = 2; //go to First_step (power gathering step) //state = 0일 때 인터럽트 INT0 발생시 게임 시작으로 인지 -> 게이지 차징 단계로 flag set up
	}
	else if (game_state == 1){ //커서가 credit 위에 있을 때 인터럽트가 걸린다면
		lcd_clear(); //크레딧 관련된 내용을 직접 처리한다.
		ScreenBuffer_clear();
		lcd_string(0, 0, "INHA UNIV.");
		lcd_string(1, 0, "MP Final project");
		lcd_string(2, 0, "PARK-INKYU");
		lcd_string(3, 0, "12121484");
		lcd_string(4, 0, "CHOO-KYOJUNG");
		lcd_string(5, 0, "12111684");
		lcd_string(6, 0, "2016. 12. 19.");
		lcd_string(7, 0, "All right reserved");
		_delay_ms(5000);
		game_state = 0;
	}
}

//게이지 차징 단계에서 게이지 차징을 하기 위한 버튼으로 PD1이 이용된다
ISR(INT1_vect){ //PD1에 대한 인터럽트 핸들링을 위한 함수
	cli();//모든 인터럽트를 막는다
	power_cnt++;//눌린 횟수를 계수한다.
	box_state = (power_cnt / (stage_number * 10)); //눌린 횟수는 파워게이지와 연결된다, 스테이지별 요구 게이지(파워)가 다 다르다
	if (box_state >= 6) box_state = 6; //스테이지가 올라갈 수록 요구 게이지는 증가함
	_delay_ms(10);
	sei();//인터럽트를 허용한다
}

void select_menu(void) //메뉴 출력 함수
{
	game_state = 0;
	unsigned char pos_bird = 110; //화면 위에 움직이는 오브젝트(새)를 출력하기 위해 기본 위치 설정
	while (1){//메뉴가 선택될 때까지 무한루프를 반복한다
		if (game_state == 2) //만약 앞서 선택된 메뉴에 의해서 game_state가 변경될 경우 무한루프 탈출한다 = 게임시작
		break;
		
		lcd_clear();
		ScreenBuffer_clear();
		
		print_bitmap(bird, pos_bird, 10, 8, 8); //오브젝트(새)를 계속해서 출력한다 (위치를 계속 변경시킨다=움직인다)
		pos_bird -= 5; if (pos_bird<0) pos_bird = 110; //왼쪽으로 5칸씩 움직이고, 끝에 도달하였을 경우, 처음 위치로 초기화
		lcd_string(3, 5, "GAME START"); //메뉴 출력
		lcd_string(4, 5, "CREDIT ");
		lcd_string(7, 3, "Choo N Kyu 2016");
		print_bitmap(lin, 13, 54, 8, 8); //오브젝트2 출력
		if (game_state == 0){//gamestart
			GLCD_Rectangle_black(24, 24, 30, 30); //선택 커서를 블랙박스를 통해 표현
		}
		else if (game_state == 1){//credit
			GLCD_Rectangle_black(32, 24, 38, 30);
		}
		_delay_ms(200);
		//조이스틱은 Data_ADC4 상/하 , Data_ADC3 좌/우 연결되어 있고, 메뉴에서는 상하 ADC4만 이용된다.
		if (Data_ADC4<20){  //up = start
			game_state = 0;    //조이스틱을 통해 ADC값이 읽혀졌을 때, 그 값이 20보다 작으면 up으로 간주
			_delay_ms(200);
		}
		else if (Data_ADC4>50){ //50보다 크다면 down으로 간주한다
			game_state = 1;
			_delay_ms(200);
		}
		Data_ADC4 = Read_Adc_Data(4) / 14; //Data4_ADC4라는 변수에 조이스틱의 입력값을 가져온다
	}
	GLCD_Rectangle_black(0, 0, 64, 128); //게임 시작을 알리는 화면 blink
	_delay_ms(200);
	ScreenBuffer_clear();
	lcd_clear();
	print_bitmap(esc, 0, 0, 128, 64); //게임 시작 스토리를 위한 이미지 및 문자열 출력
	_delay_ms(1500);
	lcd_clear();
	ScreenBuffer_clear();
	lcd_string(3, 0, "The boy is in danger!");
	_delay_ms(2500);
	lcd_string(4, 0, "Help him escape");
	_delay_ms(2500);
}

void First_step(void) //게이지를 모으는 단계
{
	t0_count = 0;

	while (1)
	{
		lcd_clear();
		ScreenBuffer_clear();

		//게이지의 상태를 시각적으로 보여주는 그래픽 출력
		GLCD_Rectangle(16, 18, 23, 18 * 6);// y1, x1, y2, x2
		GLCD_Rectangle_black(16, 18, 23, 18 * box_state);
		//PD1을 통해 설정된 box_state를 통해 게이지의 차징 상태를 표현한다
		
		lcd_string(1, 3, "time : ");
		lcd_xy(1, 11); GLCD_4DigitDecimal(15 - t0_count);
		//남은 시간을 출력한다. timer0 INT를 통해 계측된 t0_count를 이용.
		
		
		//게이지 차징 상태에 따라 케릭터를 다르게 표현한다
		if (box_state <3)//작은 케릭터
		print_bitmap(base1, 57, 38, 8, 8);
		else if (box_state >= 3) //큰 케릭터(변신 후)
		print_bitmap(jumper, 55, 30, 16, 16);


		_delay_ms(500);
		if (box_state == 6) break; //만약 게이지가 완전히 채워진다면 시간과 상관없이 다음 단계로 넘어간다
		if (t0_count >= 15) break; //시간이 15초가 경과했다면 종료한다.
		lcd_string(7, 1, "Push PD1 for power!"); //안내문
		_delay_ms(300);
	}
	lcd_clear();
	ScreenBuffer_clear();
	if (box_state < 3){ //만일 게이지가 최소 요구사항보다 채워지지 않았다면 게임이 종료된다
		GLCD_Rectangle_black(0,0,64,128);
		_delay_ms(1000);
		lcd_clear(); ScreenBuffer_clear(); _delay_ms(100);
		lcd_string(3, 0, "Power is not enough..");
		_delay_ms(2000);
		lcd_string(4, 0, "Our Boy catched...");
		_delay_ms(3000);
		lcd_clear();
		end_flag = 0; //GAME OVER를 나타내는 종료 플래그
		game_state = 5;
		return;
	}
	//게이지의 차지 상태에 따라 다음 단계에서 오브젝트와 충돌하여도 게임을 지속할 수 있는 횟수가 결정된다.
	life = box_state / 2;
	//게이지 상태는 점수와 연결된다.
	cur_score += box_state * 20;
	lcd_string(3, 4, "SCORE + ");
	lcd_xy(3, 11);
	GLCD_4DigitDecimal(box_state * 20);
	lcd_string(4, 4, "LIFE  +");
	lcd_xy(4, 13);
	GLCD_2DigitDecimal(life);
	game_state = 3;
	_delay_ms(1500);
}


void Port_init(void){//포트 초기화를 위한 함수
	PORTA = 0x00; DDRA = 0xff;
	PORTB = 0xff; DDRB = 0xff;
	PORTC = 0x00; DDRC = 0xf0;
	PORTD = 0x80; DDRD = 0x80;
	PORTE = 0x00; DDRE = 0xff;
	PORTF = 0x00; DDRF = 0x00;
}

void init_devices(void){ //장치 초기화를 위한 함수
	cli();
	Port_init();
	Adc_init();
	lcd_init();
	init_INT();
	sei();
}

//  피하기 시작후, 점프보이가 출발지에서 점프하는 장면을 출력
void start_jump(unsigned char* y, unsigned char* x){ // 점프보이의 x, y좌표에 관한 포인터를 받아옴. call by reference

	unsigned char sor = 32;   // 출발지의 x좌표
	*x = 32;      // 점프 보이의 x좌표 설정
	*y = 64 - 16;  // 점프 보이의 y좌표 설정
	while (*y >= 32){
		ScreenBuffer_clear(); // 스크린의 버퍼를 클리어
		lcd_clear();        // lcd 클리어
		*y -= 2;           // 점프보이의 y좌표를 2씩 감소하여 대각선으로 점프함을 보임
		GLCD_Circle(64, sor, 20); // x좌표가 sor인 위치에 출발지를 반원형으로 출력
		sor -= 2;           // 출발지가 점차 왼쪽으로 밀림
		print_bitmap(jumper, *x - 8, *y - 8, 16, 16); // 점프보이를 해당위치에 출력
		GLCD_Rectangle_black(60, 0, 64, 128);
		_delay_ms(100);
	}
	while (sor <= -18){       // 남은 출발지를 마자 화면에서 왼쪽으로 밀어냄
		ScreenBuffer_clear();
		lcd_clear();
		sor -= 2;
		GLCD_Circle(64, sor, 20);
		print_bitmap(jumper, *x - 8, *y - 8, 16, 16);
		GLCD_Rectangle_black(60, 0, 64, 128);
		_delay_ms(100);
	}
}

void next_stage_display(void){ // 다음 stage번호를 출력하는 함수
	++stage_number; // 다음 stage로 넘어가면서 stage번호 1증가
	lcd_clear();
	lcd_string(3, 6, "STAGE");   // STAGE 출력
	lcd_xy(3, 11);
	GLCD_2DigitDecimal(stage_number); // stage 번호출력
	_delay_ms(3000);
}

void score_display(void){   // game over 또는 game clear 후 최고 점수와 현재 점수를 출력하는 함수
	if (max_score < cur_score) max_score = cur_score; // 현재 점수가 최고 점수보다 높았다면 최고 점수를 갱신해준다.
	lcd_clear();
	lcd_string(2, 0, "Max score : "); lcd_xy(2, 10); GLCD_4DigitDecimal(max_score); // 최고 점수 출력
	lcd_string(4, 0, "Cur score : "); lcd_xy(4, 10); GLCD_4DigitDecimal(cur_score); // 현재 점수 출력
}

void ending_display(){ //게임 종료를 출력하는 함수
	lcd_clear();
	if (end_flag == 0){ //flag가 0일 경우, 실패를 의미한다
		lcd_string(3, 5, "GAME OVER");
	}
	else{//아닌 경우, 엔딩을 출력한다
		lcd_string(3, 7, "CLEAR!");
		_delay_ms(3000);
		lcd_clear();
		ScreenBuffer_clear();
		lcd_string(3, 0, "Super Jump boy");
		lcd_string(4, 0, "successly escaped!");
		_delay_ms(3000);
		lcd_clear();
		lcd_string(3, 4, "PARK-INKYU");
		_delay_ms(4000);
		lcd_clear();
		lcd_string(3, 4, "CHOO-KYOJUNG");
		_delay_ms(4000);
		lcd_clear();
		lcd_string(2, 4, "CHOO X PARK");
		lcd_string(3, 4, "2016. 12. 19");
		_delay_ms(5000);
		lcd_clear();
		lcd_string(3, 5, "THANK YOU");
		_delay_ms(3000);
		lcd_clear();
		lcd_string(3, 5, "GAME OVER");
		_delay_ms(2000);
	}

	_delay_ms(4000);
	score_display();
}

// 점프보이와 새가 충돌했는 지를 확인하는 함수
void compare(unsigned char* y, unsigned char* x, Bird* ptr, unsigned char bird_num){ // 점프보이의 x, y좌표와 Bird 구조체의 구조체변수, 새번호를 전달 받음
	if (*y - 10 <= ptr->y && ptr->y <= *y + 10 && *x - 10 <= ptr->x && ptr->x <= *x + 10){ // 점프보이와 새가 충돌했다면
		if (crash_flag[bird_num] == 0){ // 해당 bird_num의 crash_flag가 0인지 체크. 즉 처음 충돌했는지 체크
			crash_flag[bird_num] = 1;  // 현재 bird_num의 새와 충돌중임
			if (life > 1){ // life가 1 초과시 새와 충돌하면 life 1 감소
				life--;
				GLCD_Rectangle_black(0, 0, 64, 128); // 충돌시 이팩트
				_delay_ms(100);
			}
			else{
				game_state = 5; // 남은 life가 없을 때 충돌했다면 game_state에 5를 넣어 ending으로 넘어가게 함
				end_flag = 0;  // ending이 game_over임을 알림
				game_flag = 0; // 새 피하기 종료
				crash_flag[bird_num] = 0; // 해당 새와 충돌이 끝났음
			}
		}
	}
	else
	crash_flag[bird_num] = 0; // 범위를 벗어나면 해당 새와 충돌이 끝났음을 flag로 체크
}

void compare_round_time(unsigned char *y, unsigned char *x){ // 정해진 stage진행 시간보다 play_time이 커지면 stage 종료하는 함수
	if (round_time <= play_time){ // round_time보다 play_time이 커지면
		while (*y <= 30){       // 점프보이의 y좌표가 30보다 작을 때 좌표를 30으로 점차 이동
			lcd_clear();
			ScreenBuffer_clear();
			*y += 2;
			print_bitmap(jumper, *x - 8, *y - 8, 16, 16); // 점프보이 그림을 해당 좌표에 출력
			GLCD_Rectangle_black(60, 0, 64, 128);
			_delay_ms(50);
		}
		while (*y >= 30){         // 점프보이의 y좌표가 30보다 클 때 좌표를 30으로 점차 이동
			lcd_clear();
			ScreenBuffer_clear();
			*y -= 2;
			print_bitmap(jumper, *x - 8, *y - 8, 16, 16); // 점프보이 그림을 해당 좌표에 출력
			GLCD_Rectangle_black(60, 0, 64, 128);
			_delay_ms(50);
		}
		while (*x > 11){         // 점프보이의 x좌표를 왼쪽 맨 끝으로 이동
			lcd_clear();
			ScreenBuffer_clear();
			*x -= 4;
			print_bitmap(jumper, *x - 8, *y - 8, 16, 16); // 점프보이 그림을 해당 좌표에 출력
			GLCD_Rectangle_black(60, 0, 64, 128);
			_delay_ms(50);
		}

		unsigned char dest = 128;   // 목적지의 x좌표를 128으로 설정
		while (dest >= 105){         // 목적지의 x좌표가 105보다 작아질 때 까지 목적지를 점차 이동
			lcd_clear();
			ScreenBuffer_clear();
			print_bitmap(jumper, *x - 8, *y - 8, 16, 16); // 점프보이 그림을 출력
			GLCD_Circle(64, dest, 20); // 해당 x좌표(dest)에 목적지(원형) 출력
			dest -= 2;   // 목적지의 x좌표를 2씩 감소시킴
			GLCD_Rectangle_black(60, 0, 64, 128);
			_delay_ms(200);
		}

		while (*x <= dest - 24){   // 점프보이를 수평으로 약간 이동시킴
			lcd_clear();
			ScreenBuffer_clear();

			*x += 4;   // 점프보이의 x좌표를 4씩 증가
			GLCD_Circle(64, dest, 20);
			print_bitmap(jumper, *x - 8, *y - 8, 16, 16);
			GLCD_Rectangle_black(60, 0, 64, 128);
			_delay_ms(50);
		}
		while (*y <= 64 - 15){ // 점프보이가 목적지에 착지할 수 있도록 대각선방향으로 이동
			lcd_clear();
			ScreenBuffer_clear();
			*x += 2;   // 점프보이의 x좌표 2증가
			*y += 2;   // 점프보이의 y좌표 2증가
			GLCD_Circle(64, dest, 20); // 목적지는 그대로 출력
			print_bitmap(jumper, *x - 8, *y - 8, 16, 16); // 점프보이 출력
			GLCD_Rectangle_black(60, 0, 64, 128);
			_delay_ms(100);
		}
		game_flag = 0; // 새 피하기가 끝났음을 알림
		cur_score += life * 50; // 남은 life에 따른 추가 점수를 현재 점수에 더함
		if (stage_number != 3){  // stage가 3이아니었다면
			game_state = 2;      // 다음 stage로 넘어감
			_delay_ms(1500);
		}
		else{           // 현재 stage가 3이었다면
			end_flag = 1; // clear를 알리기 위해 end_flag를 1로 설정
			game_state = 5; // game종료 state설정
		}
	}
}

void joystick_move(unsigned char* y, unsigned char* x){
	Data_ADC3 = Read_Adc_Data(3) / 14; // 아날로그 3번 포트에서 값을 읽는다. 조이스틱의 y축에 해당
	Data_ADC4 = Read_Adc_Data(4) / 14; // 아날로그 4번 포트에서 값을 읽는다. 조이스틱의 x축에 해당
	// 상하 좌우 선택
	if (Data_ADC3 < 20){  // 조이스틱을 오른쪽으로 했을 때, x좌표를 +3만큼 이동
		if (*x + 11 <128)
		*x += 3;
	}
	else if (Data_ADC3 > 50){ // 조이스틱을 왼쪽으로 했을 때, x좌표를 -3만큼 이동
		if (*x - 11 > 0)
		*x -= 3;
	}
	else if (Data_ADC4 > 50){ // 조이스틱을 아래로 했을 때, y좌표를 +3만큼 이동
		if (*y + 11 < 64)
		*y += 3;
	}
	else if (Data_ADC4 < 20){ // 조이스틱을 위로 했을 때, y좌표를 -3만큼 이동
		if (*y - 11 > 0)
		*y -= 3;
	}
	print_bitmap(jumper, *x - 8, *y - 8, 16, 16); // 좌표 이동후의 점프보이 출력
	_delay_ms(100);
}


// 그림을 해당위치에 전달 받은 크기만큼 출력해주는 함수
void print_bitmap(unsigned char *test, unsigned char x, unsigned char y, unsigned char sz_x, unsigned char sz_y)
{   //출력 위치를 설정한다
	unsigned char pos_x = x;
	unsigned char pos_y = y;

	//이미지가 이차원 배열이 아닌 일차원 배열로 입력되기 때문에 구분할 필요가 있다.
	int pos = 0; //구분을 pos를 이용해서 한다.
	
	//x축을 먼저 좌에서 우로 출력하고,
	//x축의 출력이 끝나면 y축을 이동하여 다시 x축을 좌에서 우로 출력한다.
	for (int i = 0; i<sz_y; i++){
		pos_y++; pos_x = x; //
		for (int j = 0; j<sz_x / 8; j++){
			pos = i*(sz_x / 8) + j;

			for (int k = 7; k >= 0; k--){
				unsigned char temp = 1 << k;
				unsigned char res = test[pos] & temp;
				//하나의 픽셀은 한 자리의 이진수로 충분히 나타낼 수 있다
				//즉, char형 하나에 8비트를 표현할 수 있다
				//각각의 자리에 대해서 and연산을 통해 해당 자리의 비트가 1이라면 해당 위치에 점을 찍는다
				if (res)
				GLCD_Dot(pos_y, pos_x);
				pos_x++;
			}
		}
	}
}

int main(void){

	Adc_init();
	init_devices();
	Init_Timer0();
	Port_init();

	Bird bd[3]; // 3마리의 새 생성. 구조체 변수
	for (unsigned char i = 0; i < 3; ++i) // 세마리의 새가 아직 화면에서 나타나지 않았음을 의미. flag 초기화
	flag[i] = 0;

	unsigned char man_y = 0; // 점프보이의 x, y좌표를 나타내는 변수 생성
	unsigned char man_x = 0;

	lcd_clear();
	ScreenBuffer_clear();
	print_bitmap(img, 0, 0, 128, 64); // Super Jump Boy 이미지 출력
	_delay_ms(4000);
	game_state = 0; // 게임시작화면부터 시작

	while (1){
		lcd_clear();
		ScreenBuffer_clear();
		switch (game_state){    // 게임 상태를 switch 문으로 관리
			case 0: // 게임 시작화면
			select_menu();
			stage_number = 0; // stage 번호 초기화
			cur_score = 0;  // 현재 점수 초기화
			break;
			case 2:
			box_state = 1;
			power_cnt = 0; // power_cnt 초기화
			next_stage_display(); // 다음 stage화면 출력
			First_step();
			cnt = 0; // cnt 초기화
			break;
			case 3: // 새 피하기
			if (game_flag == 0){ // 새 피하기 시작 flag가 아직 set이 아니면
				start_jump(&man_y, &man_x); // 점프보이가 출발지에서 점프하는 부분 출력하는 함수
				game_flag = 1; // 새 피하기 시작 flag를 set
				play_time = 0; // play_time 초기화
				for (int i = 0; i < 3; ++i){ // 3마리의 새의 flag 초기화
					flag[i] = 0;
				}
				cnt = 0; // cnt 초기화
				for (unsigned char i = 0; i < 3; ++i){ // 3마리의 새의 y좌표와 x좌표 초기화
					set_Bird(&bd[i].y, &bd[i].x, (35 * i + 10) % 53 + 4);
				}
			}
			lcd_string(0, 0, "SCORE ");   // 좌측 상단에 SCORE 출력
			lcd_xy(0, 6);
			GLCD_4DigitDecimal(cur_score);
			lcd_string(0, 12, "LIFE * "); // 우측 상단에 남은 life 출력
			lcd_xy(0, 18);
			GLCD_2DigitDecimal(life);
			for (unsigned char i = 0; i < 3; ++i)   // 3마리의 새를 40*i시간 후 화면에 출력
			fly(40 * i, &bd[i].y, &bd[i].x, i);
			GLCD_Rectangle_black(60, 0, 64, 128);
			joystick_move(&man_y, &man_x); // 조이스틱 인식. 점프보이를 움직임

			for (unsigned char i = 0; i < 3; ++i)   // 3마리의 새와 점프보이가 충돌했는지 체크
			compare(&man_y, &man_x, &bd[i], i);

			compare_round_time(&man_y, &man_x); // stage진행 시간과 play_time과 비교하여 stage를 종료시킴
			break;
			case 5: // game over 또는 game clear 화면 출력.
			ending_display();
			for (int i = 0; i < 3; ++i) // 새의 화면 출력 flag 초기화
			flag[i] = 0;
			_delay_ms(4000);
			game_state = 0;
			break;
		}
		_delay_ms(100);
	}
	return 0;
}